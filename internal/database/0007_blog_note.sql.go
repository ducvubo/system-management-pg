// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 0007_blog_note.sql

package database

import (
	"context"
	"database/sql"
)

const createBlogNote = `-- name: CreateBlogNote :execresult
INSERT INTO blog_note (
    bl_note_id,
    bl_id,
    bl_content
) VALUES (
    ?,
    ?,
    ?
)
`

type CreateBlogNoteParams struct {
	BlNoteID  string
	BlID      string
	BlContent string
}

func (q *Queries) CreateBlogNote(ctx context.Context, arg CreateBlogNoteParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBlogNote, arg.BlNoteID, arg.BlID, arg.BlContent)
}

const deleteBlogNote = `-- name: DeleteBlogNote :exec
DELETE FROM blog_note
WHERE bl_id = ?
`

func (q *Queries) DeleteBlogNote(ctx context.Context, blID string) error {
	_, err := q.db.ExecContext(ctx, deleteBlogNote, blID)
	return err
}

const getBlogNoteByBlogId = `-- name: GetBlogNoteByBlogId :many
SELECT 
    bl_note_id,
    bl_id,
    bl_content
FROM blog_note
WHERE bl_id = ?
`

func (q *Queries) GetBlogNoteByBlogId(ctx context.Context, blID string) ([]BlogNote, error) {
	rows, err := q.db.QueryContext(ctx, getBlogNoteByBlogId, blID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BlogNote
	for rows.Next() {
		var i BlogNote
		if err := rows.Scan(&i.BlNoteID, &i.BlID, &i.BlContent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
